![Plan of action Slide](https://github.com/kymb0/IoT/raw/main/note_dir/images/steps.png)  

Before running through steps: run [packages.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/packages.sh) > set paths and alias for build (example in [environ.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/environ.sh))  

<h2>Step 1 - Build our toolchain (what is a [toolchain?](https://github.com/kymb0/IoT/blob/main/note_dir/Toolchain.md))</h2>
<details>
  <summary></summary>  

Commands for this step:
```
tar xf crosstool-ng-1.23.0.tar.xz
cd crosstool-ng-1.23.0
./configure --prefix=$BASE_INSTALL_DIR/Step-1/customtoolchain
make
make install
cd ..
cp config_file .config
ct-ng build
```  

To do this we must configure crosstool-ng, and then compile it.  
We configure with `ct-ng menuconfig` (An example config is [here](https://github.com/kymb0/IoT/blob/main/note_dir/ct-ng-config))  
most options in config are self explainatory, the only one that was not (for me) was C library. By defukat this was set to gLibc, we want uClibc - this is because uClibc is more of a "smaller and barebones library"

The actual commands to do the above are as follows, as we can see all we are doing is unpacking the offline install directory as well as changing the base install directory from `/` to `/Step-1/customtoolchain`, build crosstool-ng with `make`, install with `make install`, and then build our custome toolchain using the installed and configured crosstool-ng.  
Once built, we can see our binaries in the specified /bin/ directory - this important for later on.

</details>  

<h2>Step 2 - Configure and compile u-boot</h2>
<details>
  <summary></summary>  

Commands for this step:  
```
tar xf u-boot-2018.01.tar.bz2`  
cd u-boot-2018.01
cp ../u-boot-2018.01 .config
arm-make
```
Explaination of above:  
  
So first, we decompress u-boot.tar, and move into it, as this contains the files we need to configure and compile.  
Then we copy the config file across - Why do we need a config file?  
As we are compiling u-boot for a specific device (beagleboneblack), we will need to feed u-boot many device specific details, as u-boot will be responsible for initializing many devices.  
To locate which config to use we look inside `configs/` - which contains configs files for different processors, boards, etc. These configs tell u-boot which support needs to be compiled in aswell as env settings.  
How do we create the config file?  
For the BBB, we can find our particular configs with `ls config/am335x_*`  
this will list all relevant files - luckily for us the SoC/board manufacturer will stipulate which configs are to be used, we can gleam this from their website. In this case Texas Instruments site tells us to use `am335x_evm_defconfig` in order to boot beagleboneblack.  

It is important to note that u-boot will also look will look at the corresponding .dts file with the same naming convention as the config file specified by manufacturer, so, `am335x_evm.dts`  
This file works off a template for the entire am335 family, and inturn THAT template works off a skeleton template.  
(the dts contains large amounts of info regarding different devices, power profiles, memory locations, etc)

Now, compilation process - note `arm make` is an alias for `'ARCH=arm CROSS_COMPILE=arm-unknown-linux-uclibcgnueabihf- make'` as set by the [environ.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/environ.sh) file. Essentially it sets the architecture to arm and sets the crosscompilation toolchain to the binary installed by our custom toolchain in step 1.  
`arm-make distclean` - clean out settings  
`arm-make am335x_evm_defconfig` - using the alias, this will create a config file for us to use (we can inspect and modify via `arm-make menuconfig`)   What would we want to modify? possibly the CLI, shellprompt, boot-delay, etc. We can also include support for additional commands, filesystem support, etc.

finally after creating our config file, we run `arm-make`, after 5 or so minutes we will see our `MLO` file, aswell as u-boot.img, etc.  
</details>  

<h2>Step 3 - Compiling Kernel and Device Tree Binary</h2>
<details>
  <summary></summary>  

Commands for this step:
```
tar xf linux-4.15.7.tar.xz
cd linux-4.15.7
cp ../linux-4.15.7-config .config
ARCH=arm CROSS_COMPILE=arm-unknown-linux-uclibcgnueabihf- make -j $(nproc) zImage dtbs modules OR arm-make -j $(nproc) zImage dtbs modules
```
Explaination of above:  
extract the linux kernel (may take some time: one of, if not THE largest repo in the world)  
move into the directory (root of kernel sources)  
we need a config to make sure we compile a kernel capable of running on the beagleboneblack  

Our base defconfig file will be `arch/arm/configs/multi_v7_defconfig` as this contains support for many, many SoC's (obviously including )  
arm-make multi_v7_defconfig to make our base config  
now we customise with `arm-make menuconfig`  
something we may like to change is the kernel .config support option (a M indicates the complete `.config` file will be compiled as an external MODULE, whereas a `*` means the `.config` means it will be built in to the kernel, we want the support built in, so we select `*`)

We would also like KPROBES enabled, as this will allow us to figure many things out in the kernel at runtime - necessary for rootkits and such

[*Note*] As this kernel will be for IoT/embedded devices, as such we will be INTENTIONALLY select options to make the kernel weaker for the purpose of demonstrating rootkits. (in saying this, many IoT devices, even modern ones actualy SHIP with these settings off)  

First we UNSELECT `make kernel text and rodata read-only`, this allows us to play with the syscall table.  
We also UNSELECT `Set loadable kernel module data as NX and text as RO` 

Last we turn `SECCOMP` off in order to enable the full use of certain syscalls, in addition to turning ON `NETFILTER` which is the framework which is used to run iptables, create custom firewalls, packet routing etc. (generally on by default in anycase)  

(We can reduce size of zImage file after compilation by compiling this kernel for ONLY the am335x SoC. wWe do this at menuconfig stage by selecting in systemtypes: TI OMAP/AM family and only select am335x)

Now with these settings done, we compile the kernel (again with our alias):  
`arm-make -j $(nproc) zImage modules dtbs` nproc is number of cpus, we want to also compile in the zImage, modules we selected, aswell as device tree binary.

After this is completed, we can view the zImage files with `ls arch/arm/boot -lh`, `ls arch/arm/boot/dts/am335x-bone*` and so forth.  
</details> 

<h2>Step 4 - Create Root Filesystem</h2>
<details>
  <summary></summary>  

Commands for this step:
```
tar xf buildroot-2017.11.2.tar.gz
cd buildroot-2017.11.2
cp ../buildroot-2017.11.2-config .config
mkdir dl 
cp ../dl/* dl/
make clean
make
```
We will start by unzipping buildroot and moving into it.
Just as there were beaglebone specific config files in the kernel, we have the same situation with buildroot. We generate our config with
`arm-make configs/beaglebone_defconfig`.
Again, `arm-make menuconfig` to modify some settings: Very importantly we do not want buildroot to download and use it's own toolchain - we must change Toolchain type from the default to `external toolchain` and Toolchain from `Linaro` to `Custom toolchain`.
Toolchain prefix must be `arm-unknown-linux-uclibcgnueabihf` - this will tell buildroot how to search for our toolchain binaries. Make sure our gcc version lines up with what he have, in addition to linux kernel version we compiled.   Then we turn on wchar, local, rpc support.  
Lastly we go up one level in settings, and make sure we uncheck Kernel and bootloader as we have built our own. Now in filesystem we select tar filesystem and compression method `xz`.  
Buildroot is now configured to build out the filesystem for the beaglobone black.  
As the packages required are already downloaded, we copy them into the buildroot dl folder.  
Finally we `make` and wait a while, there may be some errors at the end however these can be ignored  
We can see our rootfs tar file in the `output/images/` dir of buildroot as well as a `uEnv.txt` file we could use if we wanted.  
</details>  

<h2>Step 5 - Preparing SD card and booting!</h2>
<details>
  <summary></summary>  

Step 5 - Bringing it all together

Now we have our: 
BOOT partition: `MLO`, `u-boot.img`, and `uEnv.txt` (created Step 2)  
KERNEL partition: `zImage` (linux kernel) and `XX.dtb` (Device Tree) (Created Step 3)  
ROOTFS Partition: `busybox`, `Sytem Utilities`, `Kernel Modules`, and `Custom Programs` (created Step 4)  

  <details>
  <summary>SD Partitioning</summary>  
    
  ![sdPartitioning](https://github.com/kymb0/IoT/raw/main/note_dir/images/sd_part.png)  
    
  </details>
  
We can achieve our partitioning with a number of tools, an wasy way is via `gparted`, typically we want `fat32 100mb` for BOOT, `ext4 1000mb`, kernel , and the rest for rootfs.

Now if we open the pre-configured eEnvtxt file, and in bootargs we CHANGE the rootfs from partition2 to partition3.

Next copy the files we need from each step with the below script/commands:
```
2/u-boot-2018.01/MLO MLO/
cp ../Step-2/u-boot-2018.01/u-boot.img u-boot/
cp ../Step-3/linux-4.15.7/arch/arm/boot/zImage kernel/
cp ../Step-3/linux-4.15.7/arch/arm/boot/dts/am335x-boneblack.dtb dtb/
cp ../Step-4/buildroot-2017.11.2/output/images/rootfs.tar.xz filesystem/ 
cp MLO/MLO /media/iot/BOOT
cp u-boot/u-boot.img /media/iot/BOOT
cp uEnv.txt /media/iot/BOOT
sudo cp kernel/zImage /media/iot/kernel
sudo cp dtb/am335x-boneblack.dtb /media/iot/BOOT
sudo tar -C /media/dev/Linux -xvJf /home/dev/testing_dir/embedded-linux/Step-5/filesystem/rootfs.tar.xz
```
Now... plug that bad boy in and power it up! *If you are connected via UART cable you will be able to monitor the boot process.
</details>

<h2>Step 6 (part 1) - Basic backdoor example</h2>
<details>
  <summary></summary>  

In this exercise we assume 2 things:  
First, our beaglebone is connected via ethernet to a bridged port to our laptop, and we are monitoring our beaglebone via UART cable.  

For this exersize we can use any of [bindshell](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/bindshell.c), [hello](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/hello_world.c), or [hello in ARM assembly](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/hello.s) to demonstrate code execution. The below section will assume bindshell.c because shells r fun. (this particular program is your standard c program however you could also utilise a c-wrapper for assembly, aka spin up msfvenom and drop it in)

We can use our cross compilation tools directly `arm-unknown-linux-uclibcgnueabihf-gcc bindshell.c -o bindshell`  
running `file` against our output binary will confirm the cross-compilation.  
The next step is to `sudo cp /var/lib/tftpboot/` and then collect from our VM `tftp -g -r bindshell 192.x.x.x`, make executable `chmod +X bindshell`  
Now we run and viola, we can `nc` into a session. This is obviously a very basic example, however these notes set the foundation for some of the cooler stuff down the road. **Note we could easily set this binary to run under certain condition (boot, etc) and also modify the code to service multiple clients and also be persistent with it's listener**  
</details>

<h2>Step 6 (part 2) - IoT rootkit primer</h2>
<details>
  <summary></summary>  


#### Following on from Part 1, these notes are very basic and later on I will do the dedicated rootkit course and create a separate note repo for more advanced rootkit techniques but for now, here are the meat and potatoes.

### Kernel module rootkit example:

Example: [helloworld.c](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/rootkits/helloworld.c)  
Can be ported to other platforms quite easily (the make file tells you what is required).  
Run as part of the kernel - has access to everything inside the kernel, can look at and modify memory etc.  

When we insert a module, the module's init routine runs.  
We may need to look at supressing log messages being print to the console when developing rootkits.  

When we compile kernel modules, we must specify an entire compiled linux source.  

Once we compile the kernel file (making use of our arm-make alias) and bring it into our device, we double check loaded modules with `lsmod` (on our barebones fresh kernel nothing should be listed).   
Now to insert the example helloworld rootkit: `insmod helloworld.ko`, we can also remove with `rmmod helloworld.ko` in this example rootkit we will see that the `init` and `exit` log messages appear in console. we can supress with `dmesg -n 1`.   

### Hiding Rootkits:
(Note that depending on your kernel, some `c` functions will change - you can use a site called bootlin to locate your kernel version, if you search your function you can locate where it is defined)  

### An example of a hidden rootkit  
Example: [iamhiding.c](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/rootkits/iamhiding.c)  
As we covered, we can view running/loaded modules with `lsmod`, however, we would much prefer our rootkit NOT to get listed and impossible to remove with `rmmod`.  

### How do we do this?   
In the rootkit code, we make a reference to ourselves `placeholder`, and then remove ourselves from the kernel's global module list `placeholder`.
You will notice that we lock the module_mutex so that any other kernel thread trying to access or modify the module list is unable to do so while we perform our operation. We unlock at the end.

### PID obfuscation  
Example: [changename.c](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/rootkits/changename.c)
In addition to hiding ourselves, we may also want to modify malware proc name eg `bindshell` appearing in `ps`
To do this we will need to take the `pid` of the proc we want to change, aswell as what we want to change it to.
So after we compile and copy over changename.ko, we can change a procs name: `insmod changename.ko process_pid=100 new_name='Linux-Kernel'`

### network stack monitoring
Example: [network.c](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/rootkits/network.c)
Example: [covert-network.c](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/rootkits/covert-network.c)
Behind common network tools such as iptables, there are a set low-level network hooks which run inside the kernel called netfilter.  
Netfilter proveds all the hooks in the network stack which allows you to use iptables to configure network firewalling etc. Netfilter provides these hooks at various locations in the protocol stack. EG a packet comes in a netfilter hook is hit (NF_IP_PRE_ROUTING), if the packet is destined for the current address it will then go to NF_IP_LOCAL_IN, if it destined for another routable IP NF_IP_FORWARD, The packet then passes a final netfilter hook NF_IP_POST_ROUTING before going back on the wire. If the packet was created locally then NF_IP_LOCAL_OUT is called. 
Almost all IoT devices will have netfilter.  
It is important to note which kernel version you are on as netfilter code can vary drastically depending which kernel you are on.  

Almost anytime a backdoor is leveraging netfilter, it will have to determine which hook to use. Similar to how when we build a listener and everything must be specified at a granular level. An example snippet is below   


```
static struct nf_hook_ops outgoing = {
        .hook = hooker, //name of our hooking function
        .hooknum = NF_IP_LOCAL_OUT, // we monitor traffic going out
        .pf = NFPROTO_IPV4, //listen for ipv4 packets
        .priority = NF_IP_PRI_LAST //give us last priority as a hook

};
```

The rest of the code is in the example code, where whenever an outgoing packet is detected, we will capture all the packet information.

The next stage of weaponisation using the network stack is a backdoor using a covert channel, which we will discuss now.

Kernel mode network backdoor:
We want to create a netfilter hook, so in the example code, we will see that we define our hook structure, looking at ipv4 PRE-routing (as soon as they come into the machine). 
We see that the hook is defined to see if the IoT device recieves a packet where both the SYN and RESET flags are set, the source and dest port numbers are 9999, then the backdoor concludes that the packet is from the C2. It then looks at the payload and displays the data in /var/log/messages (this example is not weaponised, it can be weaponised using kernel helper functions).  

```
  if(ntohs(tcp_header->source) == COVERT_SRC_TCP_PORT 
                                        && ntohs(tcp_header->dest) == COVERT_DST_TCP_PORT 
                                        && tcp_header->syn 
                                        && tcp_header->rst ) {


                                data = (unsigned char *)((unsigned char *)tcp_header + (tcp_header->doff * 4));

                                skb_tail = skb_tail_pointer(skb);


                                if(skb_tail > data) {

                                        // Yes, there is data! :) 
```

We get the ip header, check if it is a TCP packet, look at the TCP header and check that source/dest are 9999 and check that SYN and RESET flags are set. If these conditions are met we then data portion of packet, if there is data, we then conclude this is part of our covert channel, and print out the source IP and then the data portion. We return NF_drop at the end in order to drop the packet, as we do not want to process it any further due to this being a covert channel.  
</details>
