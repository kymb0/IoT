![Plan of action Slide](https://github.com/kymb0/IoT/raw/main/note_dir/images/steps.png)  

Before running through steps: run [packages.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/packages.sh) > set paths and alias for build (example in [environ.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/environ.sh))  

<h2>Step 1 - Build our toolchain (what is a [toolchain?](https://github.com/kymb0/IoT/blob/main/note_dir/Toolchain.md))</h2>
<details>
  <summary></summary>  

Commands for this step:
```
tar xf crosstool-ng-1.23.0.tar.xz
cd crosstool-ng-1.23.0
./configure --prefix=$BASE_INSTALL_DIR/Step-1/customtoolchain
make
make install
cd ..
cp config_file .config
ct-ng build
```  

To do this we must configure crosstool-ng, and then compile it.  
We configure with `ct-ng menuconfig` (An example config is [here](https://github.com/kymb0/IoT/blob/main/note_dir/ct-ng-config))  
most options in config are self explainatory, the only one that was not (for me) was C library. By defukat this was set to gLibc, we want uClibc - this is because uClibc is more of a "smaller and barebones library"

The actual commands to do the above are as follows, as we can see all we are doing is unpacking the offline install directory as well as changing the base install directory from `/` to `/Step-1/customtoolchain`, build crosstool-ng with `make`, install with `make install`, and then build our custome toolchain using the installed and configured crosstool-ng.  
Once built, we can see our binaries in the specified /bin/ directory - this important for later on.

</details>  

<h2>Step 2 - configure and compile u-boot</h2>
<details>
  <summary></summary>  

Commands for this step:  
```
tar xf u-boot-2018.01.tar.bz2`  
cd u-boot-2018.01
cp ../u-boot-2018.01 .config
arm-make
```
Explaination of above:  
  
So first, we decompress u-boot.tar, and move into it, as this contains the files we need to configure and compile.  
Then we copy the config file across - Why do we need a config file?  
As we are compiling u-boot for a specific device (beagleboneblack), we will need to feed u-boot many device specific details, as u-boot will be responsible for initializing many devices.  
To locate which config to use we look inside `configs/` - which contains configs files for different processors, boards, etc. These configs tell u-boot which support needs to be compiled in aswell as env settings.  
How do we create the config file?  
For the BBB, we can find our particular configs with `ls config/am335x_*`  
this will list all relevant files - luckily for us the SoC/board manufacturer will stipulate which configs are to be used, we can gleam this from their website. In this case Texas Instruments site tells us to use `am335x_evm_defconfig` in order to boot beagleboneblack.  

It is important to note that u-boot will also look will look at the corresponding .dts file with the same naming convention as the config file specified by manufacturer, so, `am335x_evm.dts`  
This file works off a template for the entire am335 family, and inturn THAT template works off a skeleton template.  
(the dts contains large amounts of info regarding different devices, power profiles, memory locations, etc)

Now, compilation process - note `arm make` is an alias for `'ARCH=arm CROSS_COMPILE=arm-unknown-linux-uclibcgnueabihf- make'` as set by the [environ.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/environ.sh) file. Essentially it sets the architecture to arm and sets the crosscompilation toolchain to the binary installed by our custom toolchain in step 1.  
`arm-make distclean` - clean out settings  
`arm-make am335x_evm_defconfig` - using the alias, this will create a config file for us to use (we can inspect and modify via `arm-make menuconfig`)   What would we want to modify? possibly the CLI, shellprompt, boot-delay, etc. We can also include support for additional commands, filesystem support, etc.

finally after creating our config file, we run `arm-make`, after 5 or so minutes we will see our `MLO` file, aswell as u-boot.img, etc.  
</details>  

<h2>Step 3 - compiling kernel and device tree binary</h2>
<details>
  <summary></summary>  

Commands for this step:
```
tar xf linux-4.15.7.tar.xz
cd linux-4.15.7
cp ../linux-4.15.7-config .config
ARCH=arm CROSS_COMPILE=arm-unknown-linux-uclibcgnueabihf- make -j $(nproc) zImage dtbs modules OR arm-make -j $(nproc) zImage dtbs modules
```
Explaination of above:  
extract the linux kernel (may take some time: one of, if not THE largest repo in the world)  
move into the directory (root of kernel sources)  
we need a config to make sure we compile a kernel capable of running on the beagleboneblack  

Our base defconfig file will be `arch/arm/configs/multi_v7_defconfig` as this contains support for many, many SoC's (obviously including )  
arm-make multi_v7_defconfig to make our base config  
now we customise with `arm-make menuconfig`  
something we may like to change is the kernel .config support option (a M indicates the complete `.config` file will be compiled as an external MODULE, whereas a `*` means the `.config` means it will be built in to the kernel, we want the support built in, so we select `*`)

We would also like KPROBES enabled, as this will allow us to figure many things out in the kernel at runtime - necessary for rootkits and such

[*Note*] As this kernel will be for IoT/embedded devices, as such we will be INTENTIONALLY select options to make the kernel weaker for the purpose of demonstrating rootkits. (in saying this, many IoT devices, even modern ones actualy SHIP with these settings off)  

First we UNSELECT `make kernel text and rodata read-only`, this allows us to play with the syscall table.  
We also UNSELECT `Set loadable kernel module data as NX and text as RO` 

Last we turn `SECCOMP` off in order to enable the full use of certain syscalls, in addition to turning ON `NETFILTER` which is the framework which is used to run iptables, create custom firewalls, packet routing etc. (generally on by default in anycase)  

(We can reduce size of zImage file after compilation by compiling this kernel for ONLY the am335x SoC. wWe do this at menuconfig stage by selecting in systemtypes: TI OMAP/AM family and only select am335x)

Now with these settings done, we compile the kernel (again with our alias):  
`arm-make -j $(nproc) zImage modules dtbs` nproc is number of cpus, we want to also compile in the zImage, modules we selected, aswell as device tree binary.

After this is completed, we can view the zImage files with `ls arch/arm/boot -lh`, `ls arch/arm/boot/dts/am335x-bone*` and so forth.  
</details> 

<h2>Step 4 - Create root filesystem</h2>
<details>
  <summary></summary>  

Commands for this step:
```
tar xf buildroot-2017.11.2.tar.gz
cd buildroot-2017.11.2
cp ../buildroot-2017.11.2-config .config
mkdir dl 
cp ../dl/* dl/
make clean
make
```
We will start by unzipping buildroot and moving into it.
Just as there were beaglebone specific config files in the kernel, we have the same situation with buildroot. We generate our config with
`arm-make configs/beaglebone_defconfig`.
Again, `arm-make menuconfig` to modify some settings: Very importantly we do not want buildroot to download and use it's own toolchain - we must change Toolchain type from the default to `external toolchain` and Toolchain from `Linaro` to `Custom toolchain`.
Toolchain prefix must be `arm-unknown-linux-uclibcgnueabihf` - this will tell buildroot how to search for our toolchain binaries. Make sure our gcc version lines up with what he have, in addition to linux kernel version we compiled.   Then we turn on wchar, local, rpc support.  
Lastly we go up one level in settings, and make sure we uncheck Kernel and bootloader as we have built our own. Now in filesystem we select tar filesystem and compression method `xz`.  
Buildroot is now configured to build out the filesystem for the beaglobone black.  
As the packages required are already downloaded, we copy them into the buildroot dl folder.  
Finally we `make` and wait a while, there may be some errors at the end however these can be ignored  
We can see our rootfs tar file in the `output/images/` dir of buildroot as well as a `uEnv.txt` file we could use if we wanted.  
</details>  
