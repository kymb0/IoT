![Plan of action Slide](https://github.com/kymb0/IoT/raw/main/note_dir/images/steps.png)  

Before running through steps: run [packages.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/packages.sh) > set paths and alias for build (example in [environ.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/environ.sh))  
#### Step 1 breakdown:  
Build our toolchain (what is a [toolchain?](https://github.com/kymb0/IoT/blob/main/note_dir/Toolchain.md))  
To do this we must configure crosstool-ng, and then compile it.  
We configure with `ct-ng menuconfig` (An example config is [here](https://github.com/kymb0/IoT/blob/main/note_dir/ct-ng-config))  
most options in config are self explainatory, the only one that was not (for me) was C library. By defukat this was set to gLibc, we want uClibc - this is because uClibc is more of a "smaller and barebones library"

The actual commands to do the above are as follows, as we can see all we are doing is unpacking the offline install directory as well as changing the base install directory from `/` to `/Step-1/customtoolchain`, build crosstool-ng with `make`, install with `make install`, and then build our custome toolchain using the installed and configured crosstool-ng.  
Once built, we can see our binaries in the specified /bin/ directory - this important for later on.
```
tar xf crosstool-ng-1.23.0.tar.xz
cd crosstool-ng-1.23.0
./configure --prefix=$BASE_INSTALL_DIR/Step-1/customtoolchain
make
make install
cd ..
cp config_file .config
ct-ng build
```
### Step 2 breakdown: 
configure and compile u-boot
The commands are as below, and a breakdown of how we create the config file as well the `arm-make` alias are below
```
tar xf u-boot-2018.01.tar.bz2`  
cd u-boot-2018.01
cp ../u-boot-2018.01 .config
arm-make
```
So first, we decompress u-boot.tar, and move into it, as this contains the files we need to configure and compile.  
Then we copy the config file across - Why do we need a config file?  
As we are compiling u-boot for a specific device (beagleboneblack), we will need to feed u-boot many device specific details, as u-boot will be responsible for initializing many devices.  
To locate which config to use we look inside `configs/` - which contains configs files for different processors, boards, etc. These configs tell u-boot which support needs to be compiled in aswell as env settings.  
How do we create the config file?  
For the BBB, we can find our particular configs with `ls config/am335x_*`  
this will list all relevant files - luckily for us the SoC/board manufacturer will stipulate which configs are to be used, we can gleam this from their website. In this case Texas Instruments site tells us to use `am335x_evm_defconfig` in order to boot beagleboneblack.  

It is important to note that u-boot will also look will look at the corresponding .dts file with the same naming convention as the config file specified by manufacturer, so, `am335x_evm.dts`  
This file works off a template for the entire am335 family, and inturn THAT template works off a skeleton template.  
(the dts contains large amounts of info regarding different devices, power profiles, memory locations, etc)

Now, compilation process - note `arm make` is an alias for `'ARCH=arm CROSS_COMPILE=arm-unknown-linux-uclibcgnueabihf- make'` as set by the [environ.sh](https://github.com/kymb0/IoT/blob/main/note_dir/example_files/environ.sh) file. Essentially it sets the architecture to arm and sets the crosscompilation toolchain to the binary installed by our custom toolchain in step 1.  
`arm-make distclean` - clean out settings  
`arm-make am335x_evm_defconfig` - using the alias, this will create a config file for us to use (we can inspect and modify via `arm-make menuconfig`)   What would we want to modify? possibly the CLI, shellprompt, boot-delay, etc. We can also include support for additional commands, filesystem support, etc.

finally after creating our config file, we run `arm-make`, after 5 or so minutes we will see our `MLO` file, aswell as u-boot.img, etc.
